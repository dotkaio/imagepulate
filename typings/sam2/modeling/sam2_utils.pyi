"""
This type stub file was generated by pyright.
"""

import numpy as np
import torch
import torch.nn as nn
from typing import Tuple

def select_closest_cond_frames(frame_idx, cond_frame_outputs, max_cond_frame_num): # -> tuple[Any | dict[Any, Any], dict[Any, Any]]:
    """
    Select up to `max_cond_frame_num` conditioning frames from `cond_frame_outputs`
    that are temporally closest to the current frame at `frame_idx`. Here, we take
    - a) the closest conditioning frame before `frame_idx` (if any);
    - b) the closest conditioning frame after `frame_idx` (if any);
    - c) any other temporally closest conditioning frames until reaching a total
         of `max_cond_frame_num` conditioning frames.

    Outputs:
    - selected_outputs: selected items (keys & values) from `cond_frame_outputs`.
    - unselected_outputs: items (keys & values) not selected in `cond_frame_outputs`.
    """
    ...

def get_1d_sine_pe(pos_inds, dim, temperature=...): # -> Tensor:
    """
    Get 1D sine positional embedding as in the original Transformer paper.
    """
    ...

def get_activation_fn(activation): # -> Callable[..., Tensor]:
    """Return an activation function given a string"""
    ...

def get_clones(module, N): # -> ModuleList:
    ...

class DropPath(nn.Module):
    def __init__(self, drop_prob=..., scale_by_keep=...) -> None:
        ...
    
    def forward(self, x):
        ...
    


class MLP(nn.Module):
    def __init__(self, input_dim: int, hidden_dim: int, output_dim: int, num_layers: int, activation: nn.Module = ..., sigmoid_output: bool = ...) -> None:
        ...
    
    def forward(self, x): # -> Tensor | Any:
        ...
    


class LayerNorm2d(nn.Module):
    def __init__(self, num_channels: int, eps: float = ...) -> None:
        ...
    
    def forward(self, x: torch.Tensor) -> torch.Tensor:
        ...
    


def sample_box_points(masks: torch.Tensor, noise: float = ..., noise_bound: int = ..., top_left_label: int = ..., bottom_right_label: int = ...) -> Tuple[np.array, np.array]:
    """
    Sample a noised version of the top left and bottom right corners of a given `bbox`

    Inputs:
    - masks: [B, 1, H,W] boxes, dtype=torch.Tensor
    - noise: noise as a fraction of box width and height, dtype=float
    - noise_bound: maximum amount of noise (in pure pixesl), dtype=int

    Returns:
    - box_coords: [B, num_pt, 2], contains (x, y) coordinates of top left and bottom right box corners, dtype=torch.float
    - box_labels: [B, num_pt], label 2 is reserverd for top left and 3 for bottom right corners, dtype=torch.int32
    """
    ...

def sample_random_points_from_errors(gt_masks, pred_masks, num_pt=...): # -> tuple[Tensor, Tensor]:
    """
    Sample `num_pt` random points (along with their labels) independently from the error regions.

    Inputs:
    - gt_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool
    - pred_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool or None
    - num_pt: int, number of points to sample independently for each of the B error maps

    Outputs:
    - points: [B, num_pt, 2], dtype=torch.float, contains (x, y) coordinates of each sampled point
    - labels: [B, num_pt], dtype=torch.int32, where 1 means positive clicks and 0 means
      negative clicks
    """
    ...

def sample_one_point_from_error_center(gt_masks, pred_masks, padding=...): # -> tuple[Tensor, Tensor]:
    """
    Sample 1 random point (along with its label) from the center of each error region,
    that is, the point with the largest distance to the boundary of each error region.
    This is the RITM sampling method from https://github.com/saic-vul/ritm_interactive_segmentation/blob/master/isegm/inference/clicker.py

    Inputs:
    - gt_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool
    - pred_masks: [B, 1, H_im, W_im] masks, dtype=torch.bool or None
    - padding: if True, pad with boundary of 1 px for distance transform

    Outputs:
    - points: [B, 1, 2], dtype=torch.float, contains (x, y) coordinates of each sampled point
    - labels: [B, 1], dtype=torch.int32, where 1 means positive clicks and 0 means negative clicks
    """
    ...

def get_next_point(gt_masks, pred_masks, method): # -> tuple[Tensor, Tensor]:
    ...

