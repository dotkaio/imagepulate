"""
This type stub file was generated by pyright.
"""

import numpy as np
import torch
from typing import Any, Dict, Generator, ItemsView, List, Tuple

class MaskData:
    """
    A structure for storing masks and their related data in batched format.
    Implements basic filtering and concatenation.
    """
    def __init__(self, **kwargs) -> None:
        ...
    
    def __setitem__(self, key: str, item: Any) -> None:
        ...
    
    def __delitem__(self, key: str) -> None:
        ...
    
    def __getitem__(self, key: str) -> Any:
        ...
    
    def items(self) -> ItemsView[str, Any]:
        ...
    
    def filter(self, keep: torch.Tensor) -> None:
        ...
    
    def cat(self, new_stats: MaskData) -> None:
        ...
    
    def to_numpy(self) -> None:
        ...
    


def is_box_near_crop_edge(boxes: torch.Tensor, crop_box: List[int], orig_box: List[int], atol: float = ...) -> torch.Tensor:
    """Filter masks at the edge of a crop, but not at the edge of the original image."""
    ...

def box_xyxy_to_xywh(box_xyxy: torch.Tensor) -> torch.Tensor:
    ...

def batch_iterator(batch_size: int, *args) -> Generator[List[Any], None, None]:
    ...

def mask_to_rle_pytorch(tensor: torch.Tensor) -> List[Dict[str, Any]]:
    """
    Encodes masks to an uncompressed RLE, in the format expected by
    pycoco tools.
    """
    ...

def rle_to_mask(rle: Dict[str, Any]) -> np.ndarray:
    """Compute a binary mask from an uncompressed RLE."""
    ...

def area_from_rle(rle: Dict[str, Any]) -> int:
    ...

def calculate_stability_score(masks: torch.Tensor, mask_threshold: float, threshold_offset: float) -> torch.Tensor:
    """
    Computes the stability score for a batch of masks. The stability
    score is the IoU between the binary masks obtained by thresholding
    the predicted mask logits at high and low values.
    """
    ...

def build_point_grid(n_per_side: int) -> np.ndarray:
    """Generates a 2D grid of points evenly spaced in [0,1]x[0,1]."""
    ...

def build_all_layer_point_grids(n_per_side: int, n_layers: int, scale_per_layer: int) -> List[np.ndarray]:
    """Generates point grids for all crop layers."""
    ...

def generate_crop_boxes(im_size: Tuple[int, ...], n_layers: int, overlap_ratio: float) -> Tuple[List[List[int]], List[int]]:
    """
    Generates a list of crop boxes of different sizes. Each layer
    has (2**i)**2 boxes for the ith layer.
    """
    ...

def uncrop_boxes_xyxy(boxes: torch.Tensor, crop_box: List[int]) -> torch.Tensor:
    ...

def uncrop_points(points: torch.Tensor, crop_box: List[int]) -> torch.Tensor:
    ...

def uncrop_masks(masks: torch.Tensor, crop_box: List[int], orig_h: int, orig_w: int) -> torch.Tensor:
    ...

def remove_small_regions(mask: np.ndarray, area_thresh: float, mode: str) -> Tuple[np.ndarray, bool]:
    """
    Removes small disconnected regions and holes in a mask. Returns the
    mask and an indicator of if the mask has been modified.
    """
    ...

def coco_encode_rle(uncompressed_rle: Dict[str, Any]) -> Dict[str, Any]:
    ...

def batched_mask_to_box(masks: torch.Tensor) -> torch.Tensor:
    """
    Calculates boxes in XYXY format around masks. Return [0,0,0,0] for
    an empty mask. For input shape C1xC2x...xHxW, the output shape is C1xC2x...x4.
    """
    ...

