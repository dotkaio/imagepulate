"""
This type stub file was generated by pyright.
"""

import torch

def get_sdpa_settings(): # -> tuple[Any | Literal[True], Any | Literal[False], bool]:
    ...

def get_connected_components(mask):
    """
    Get the connected components (8-connectivity) of binary masks of shape (N, 1, H, W).

    Inputs:
    - mask: A binary mask tensor of shape (N, 1, H, W), where 1 is foreground and 0 is
            background.

    Outputs:
    - labels: A tensor of shape (N, 1, H, W) containing the connected component labels
              for foreground pixels and 0 for background pixels.
    - counts: A tensor of shape (N, 1, H, W) containing the area of the connected
              components for foreground pixels and 0 for background pixels.
    """
    ...

def mask_to_box(masks: torch.Tensor): # -> Tensor:
    """
    compute bounding box given an input mask

    Inputs:
    - masks: [B, 1, H, W] masks, dtype=torch.Tensor

    Returns:
    - box_coords: [B, 1, 4], contains (x, y) coordinates of top left and bottom right box corners, dtype=torch.Tensor
    """
    ...

class AsyncVideoFrameLoader:
    """
    A list of video frames to be load asynchronously without blocking session start.
    """
    def __init__(self, img_paths, image_size, offload_video_to_cpu, img_mean, img_std, compute_device) -> None:
        ...
    
    def __getitem__(self, index): # -> Tensor:
        ...
    
    def __len__(self): # -> int:
        ...
    


def load_video_frames(video_path, image_size, offload_video_to_cpu, img_mean=..., img_std=..., async_loading_frames=..., compute_device=...): # -> tuple[Tensor, Any, Any] | tuple[AsyncVideoFrameLoader, int | None, int | None] | tuple[Tensor, Any | int, Any | int]:
    """
    Load the video frames from video_path. The frames are resized to image_size as in
    the model and are loaded to GPU if offload_video_to_cpu=False. This is used by the demo.
    """
    ...

def load_video_frames_from_jpg_images(video_path, image_size, offload_video_to_cpu, img_mean=..., img_std=..., async_loading_frames=..., compute_device=...): # -> tuple[AsyncVideoFrameLoader, int | None, int | None] | tuple[Tensor, Any | int, Any | int]:
    """
    Load the video frames from a directory of JPEG files ("<frame_index>.jpg" format).

    The frames are resized to image_size x image_size and are loaded to GPU if
    `offload_video_to_cpu` is `False` and to CPU if `offload_video_to_cpu` is `True`.

    You can load a frame asynchronously by setting `async_loading_frames` to `True`.
    """
    ...

def load_video_frames_from_video_file(video_path, image_size, offload_video_to_cpu, img_mean=..., img_std=..., compute_device=...): # -> tuple[Tensor, Any, Any]:
    """Load the video frames from a video file."""
    ...

def fill_holes_in_mask_scores(mask, max_area): # -> Tensor:
    """
    A post processor to fill small holes in mask scores with area under `max_area`.
    """
    ...

def concat_points(old_point_inputs, new_points, new_labels): # -> dict[str, Any | Tensor]:
    """Add new points and labels to previous point inputs (add at the end)."""
    ...

